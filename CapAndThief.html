<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>경찰 과 도둑: City Defense (v0.0.4)</title>
    <style>
        body { margin: 0; height: 100vh; background-color: #000; display: flex; justify-content: center; align-items: center; font-family: 'Malgun Gothic', sans-serif; overflow: hidden; }
        canvas { background-color: #111; border: 4px solid #333; box-shadow: 0 0 40px rgba(0, 100, 255, 0.15); image-rendering: pixelated; max-width: 100%; max-height: 100%; outline: none; cursor: default; }
        #versionTag { position: absolute; bottom: 10px; right: 15px; color: #ffffff; font-size: 14px; font-weight: bold; font-family: monospace; pointer-events: none; z-index: 9999; background-color: rgba(0, 0, 0, 0.5); padding: 2px 6px; border-radius: 4px; }
        
        /* 랭킹 UI: 입력창 포커스 시 게임 이벤트 간섭 방지 */
        #rankingUI { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); border: 2px solid #FF0000; padding: 30px; text-align: center; color: white; width: 400px; border-radius: 15px; z-index: 5000; }
        #rankingUI h2 { margin-top: 0; color: #FF4444; font-size: 32px; }
        #rankForm input { padding: 12px; font-size: 16px; width: 70%; background: #222; border: 1px solid #555; color: white; text-align: center; margin-bottom: 10px; outline: none; }
        #rankForm input:focus { border-color: #00FFFF; }
        #rankForm button { padding: 10px 20px; font-size: 16px; cursor: pointer; background: #FF4444; border: none; font-weight: bold; color: white; border-radius: 5px; }
        
        #leaderboard { margin-top: 20px; max-height: 180px; overflow-y: auto; text-align: left; font-size: 14px; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 5px; }
        .rank-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #444; }
        .restart-btn { background: #444; color: white; border: 1px solid #777; padding: 10px 20px; cursor: pointer; margin-top: 20px; border-radius: 5px; font-weight: bold; }
        .restart-btn:hover { background: #666; }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="600" tabindex="0"></canvas>
    <div id="versionTag">Ver 0.0.4</div>

    <div id="rankingUI">
        <h2>GAME OVER</h2>
        <p id="finalScore" style="font-size: 20px; color: cyan; font-weight: bold; margin: 15px 0;">점수: 0</p>
        <div id="rankForm">
            <input type="text" id="userName" placeholder="이름 입력 (최대 8자)" maxlength="8" onkeydown="event.stopPropagation()">
            <button onclick="submitRanking()">랭킹 등록</button>
        </div>
        <div id="leaderboard"></div>
        <button onclick="restartGameFromUI()" class="restart-btn">다시 시작하기</button>
    </div>

    <script>
        // Apps Script URL 유지
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzJHrZ-p5oaw2h85Fumk4KpymyV0s52p6j1tDhfpUQRz6Azhg7nJZscHbxtAcKm1wdi8w/exec"; 

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const rankingUI = document.getElementById("rankingUI");
        const rankForm = document.getElementById("rankForm");
        const leaderboardDiv = document.getElementById("leaderboard");
        
        canvas.focus(); 
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = canvas.width; maskCanvas.height = canvas.height;
        const maskCtx = maskCanvas.getContext('2d');

        const gameState = {
            screen: 'start', isPaused: false, score: 0, arrests: 0, prisoners: 0, 
            startTime: 0, pauseStartTime: 0, totalPausedTime: 0, intelObtained: false,
            messages: [], globalTimer: 0, wasInStation: false, itemSpawnTimer: 0,
            freezeActiveTime: 0, maxFreezeTime: 600, slowAuraActiveTime: 0, maxSlowAuraTime: 1800 
        };

        const worldState = { x: 1, y: 1 };
        const mapConfig = { rows: 4, cols: 5, bWidth: 100, bHeight: 80, gap: 50, startX: 0, startY: 0 };
        const player = { x: 0, y: 0, size: 24, speed: 2.5, baseSpeed: 2.5, sprintSpeed: 4.5, currentDisplaySpeed: 0, color: '#003366', rotation: -Math.PI/2, viewDistance: 260, fov: Math.PI / 2.0, ambientRadius: 70, stamina: 100, maxStamina: 100 };

        let robbers = []; let items = [];
        const MAX_ROBBERS = 30; const MAX_CENTER_ROBBERS = 5;

        class Robber {
            constructor(wx, wy, spawnX, spawnY) {
                this.active = true; this.worldX = wx; this.worldY = wy; this.x = spawnX; this.y = spawnY; this.size = 20;
                const elapsedSec = (getCurrentGameTime() - gameState.startTime) / 1000;
                const timeDifficulty = Math.floor(elapsedSec / 10) * 0.01;
                const arrestDifficulty = gameState.arrests * 0.01;
                this.baseSpeed = 1.0 + timeDifficulty + arrestDifficulty; 
                this.sprintSpeed = Math.min(5.0, this.baseSpeed + 1.5);            
                this.speed = this.baseSpeed;
                this.color = '#c0392b'; this.path = []; this.targetNode = null; this.roamTarget = null;
                this.offScreenTimer = 0; this.stamina = 100; this.state = 'ROAM'; 
            }
        }

        class Item { constructor(wx, wy, x, y, type) { this.worldX = wx; this.worldY = wy; this.x = x; this.y = y; this.type = type; this.size = 15; this.bounceOffset = 0; if (type === 'FREEZE') this.color = '#00FFFF'; else if (type === 'SLOW_AURA') this.color = '#FFA500'; } }
        const spawner = { nextSpawnTime: 0, interval: 15000, targetWX: 1, targetWY: 1, targetBuildingIdx: 0 };
        const keys = { w: false, a: false, s: false, d: false, shift: false };
        let buildings = []; let policeStation = null; let roadNodes = [];
        const buildingColors = ['#8d6e63', '#78909c', '#a1887f', '#546e7a', '#6d4c41'];

        function getMousePos(evt) { const rect = canvas.getBoundingClientRect(); return { x: (evt.clientX - rect.left) * (canvas.width / rect.width), y: (evt.clientY - rect.top) * (canvas.height / rect.height) }; }
        function getCurrentGameTime() { return (gameState.isPaused ? gameState.pauseStartTime : Date.now()) - gameState.totalPausedTime; }
        function showGameMessage(text, color, time) { gameState.messages.push({ text, color, life: time }); if (gameState.messages.length > 5) gameState.messages.shift(); }
        function getRobberCountInStage(wx, wy) { return robbers.filter(r => r.worldX === wx && r.worldY === wy).length; }

        function submitRanking() {
            const name = document.getElementById("userName").value.trim();
            if (!name) { alert("이름을 입력해주세요!"); return; }
            const btn = document.querySelector('#rankForm button');
            btn.innerText = "저장 중..."; btn.disabled = true;
            const timeStr = document.getElementById("finalScore").getAttribute("data-time");
            const iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.name = 'hidden_iframe'; document.body.appendChild(iframe);
            const form = document.createElement('form'); form.method = 'POST'; form.action = SCRIPT_URL; form.target = 'hidden_iframe';
            [['name', name], ['score', gameState.score], ['time', timeStr]].forEach(d => { const input = document.createElement('input'); input.name = d[0]; input.value = d[1]; form.appendChild(input); });
            document.body.appendChild(form); form.submit();
            setTimeout(() => { alert("랭킹 등록 완료!"); document.body.removeChild(form); document.body.removeChild(iframe); rankForm.style.display = "none"; fetchLeaderboard(); }, 1000);
        }

        function fetchLeaderboard() {
            leaderboardDiv.innerHTML = "<p style='text-align:center;'>순위표 로딩 중...</p>";
            const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 5000);
            fetch(SCRIPT_URL, { signal: controller.signal }).then(res => res.json()).then(data => {
                clearTimeout(timeoutId); let html = "";
                if (!data || data.length === 0) html = "<p style='text-align:center;'>등록된 랭킹이 없습니다.</p>";
                else data.forEach((row, index) => { let medal = index === 0 ? "🥇" : index === 1 ? "🥈" : index === 2 ? "🥉" : `${index+1}.`; html += `<div class="rank-row"><span>${medal} ${row[0]}</span><span style="flex-grow:1; text-align:right; margin-right:10px;">${row[1]}점</span><span style="color:#aaa;">${row[2]}</span></div>`; });
                leaderboardDiv.innerHTML = html;
            }).catch(() => { leaderboardDiv.innerHTML = "<p style='text-align:center; color:#ff5555;'>서버 연결 실패</p>"; });
        }

        // 재시작 시 캔버스에 포커스를 주어 즉시 조작 가능하게 함
        function restartGameFromUI() { rankingUI.style.display = "none"; initGame(); canvas.focus(); }

        function initGame() {
            rankingUI.style.display = "none"; gameState.score = 0; gameState.arrests = 0; gameState.prisoners = 0; gameState.startTime = Date.now(); gameState.totalPausedTime = 0; gameState.intelObtained = false; gameState.isPaused = false; gameState.messages = []; gameState.wasInStation = false; gameState.itemSpawnTimer = 0; gameState.freezeActiveTime = 0; gameState.slowAuraActiveTime = 0; player.stamina = player.maxStamina; robbers = []; items = []; spawner.interval = 15000; pickNewTarget(); createCity('init'); gameState.screen = 'playing';
        }

        function pickNewTarget() { const reduction = Math.floor(gameState.score / 100); let intervalSec = Math.max(1, 10 - reduction); spawner.interval = intervalSec * 1000; spawner.nextSpawnTime = getCurrentGameTime() + spawner.interval; spawner.targetWX = Math.floor(Math.random() * 3); spawner.targetWY = Math.floor(Math.random() * 3); spawner.targetBuildingIdx = Math.floor(Math.random() * 20); showGameMessage(`⚠️ 범죄 모의 포착! ${intervalSec}초 후 침입!`, "yellow", 240); }

        function spawnRandomItem() {
            const wx = Math.floor(Math.random() * 3); const wy = Math.floor(Math.random() * 3); let ix, iy;
            if (Math.random() > 0.5) { ix = Math.random() * canvas.width; iy = (canvas.height - 470)/2 - 25 + Math.floor(Math.random() * 5) * 130; }
            else { ix = (canvas.width - 700)/2 - 25 + Math.floor(Math.random() * 6) * 150; iy = Math.random() * canvas.height; }
            ix = Math.max(20, Math.min(canvas.width-20, ix)); iy = Math.max(20, Math.min(canvas.height-20, iy));
            items.push(new Item(wx, wy, ix, iy, Math.random() > 0.5 ? 'FREEZE' : 'SLOW_AURA'));
            showGameMessage("🎁 지원 물자 투하!", "#FFFFFF", 180);
        }

        function spawnRobber() {
            let sx = canvas.width/2, sy = canvas.height/2;
            if (spawner.targetWX === 1 && spawner.targetWY === 1 && getRobberCountInStage(1, 1) >= MAX_CENTER_ROBBERS) { spawner.targetWX = Math.random() > 0.5 ? 0 : 2; }
            if (worldState.x === spawner.targetWX && worldState.y === spawner.targetWY) { const b = buildings[spawner.targetBuildingIdx] || buildings[0]; sx = b.x + b.w/2; sy = b.y + b.h + 10; }
            robbers.push(new Robber(spawner.targetWX, spawner.targetWY, sx, sy));
            showGameMessage("🚨 도둑 침입!", "red", 240); pickNewTarget();
        }

        function createCity(from = null) {
            buildings = []; policeStation = null;
            const isCenter = worldState.x === 1 && worldState.y === 1;
            for (let r=0; r<4; r++) { for (let c=0; c<5; c++) {
                if (isCenter && (r === 1 || r === 2) && c === 2) continue;
                const bx = (canvas.width - 700)/2 + c*150; const by = (canvas.height - 470)/2 + r*130;
                buildings.push({ x: bx, y: by, w: 100, h: 80, color: buildingColors[(worldState.x*10+worldState.y+r+c)%5], floors: (r+c)%3+2 });
            }}
            if (isCenter) policeStation = { x: canvas.width/2-36, y: canvas.height/2-27, w: 72, h: 54 };
            if (from === 'left') player.x = canvas.width - 40; else if (from === 'right') player.x = 40; else if (from === 'up') player.y = canvas.height - 40; else if (from === 'down') player.y = 40; else if (from === 'init') { player.x = canvas.width/2; player.y = canvas.height/2+80; }
            createRoadGraph(); syncRobbersPosition();
        }

        function createRoadGraph() { roadNodes = []; for(let r=0; r<=4; r++) { for(let c=0; c<=5; c++){ const nx = Math.max(20, Math.min(canvas.width-20, (canvas.width-700)/2-25+c*150)); const ny = Math.max(20, Math.min(canvas.height-20, (canvas.height-470)/2-25+r*130)); let blocked = buildings.some(b => nx>b.x-5 && nx<b.x+b.w+5 && ny>b.y-5 && ny<b.y+b.h+5); if (policeStation && nx>policeStation.x-5 && nx<policeStation.x+policeStation.w+5 && ny>policeStation.y-5 && ny<policeStation.y+policeStation.h+5) blocked = true; if(!blocked) roadNodes.push({ x: nx, y: ny, neighbors: [], isExit: (c===0 || c===5 || r===0 || r===4) }); }} roadNodes.forEach(n => { roadNodes.forEach(o => { if (n!==o && ((Math.abs(n.x-o.x)<5 && Math.abs(n.y-o.y)<150) || (Math.abs(n.y-o.y)<5 && Math.abs(n.x-o.x)<170))) n.neighbors.push(o); }); }); }
        function syncRobbersPosition() { robbers.forEach(r => { if (r.worldX === worldState.x && r.worldY === worldState.y && r.x === 0) { const n = roadNodes[Math.floor(Math.random()*roadNodes.length)]; r.x = n.x; r.y = n.y; } }); }
        function checkCollision(obj, nx, ny) { const s = obj.size-4; return buildings.some(b => nx-s/2 < b.x+b.w && nx+s/2 > b.x && ny-s/2 < b.y+b.h && ny+s/2 > b.y) || (policeStation && obj!==player && nx-s/2 < policeStation.x+policeStation.w && nx+s/2 > policeStation.x && ny-s/2 < policeStation.y+policeStation.h && ny+s/2 > policeStation.y); }
        function getNearestNode(x, y) { let near = null, minDist = Infinity; roadNodes.forEach(n => { const d = Math.hypot(n.x-x, n.y-y); if(d < minDist) { minDist = d; near = n; } }); return near; }
        function getBestFleeNode(r, curr) { let best = null, maxD = -Infinity; curr.neighbors.forEach(n => { const d = Math.hypot(n.x-player.x, n.y-player.y); if(d > maxD) { maxD = d; best = n; } }); return best; }

        function update() {
            if (gameState.screen === 'gameover') return;
            if (gameState.screen !== 'playing' || gameState.isPaused) return;
            if (robbers.length > MAX_ROBBERS) { gameState.screen = 'gameover'; return; }
            if (gameState.freezeActiveTime > 0) { gameState.freezeActiveTime--; spawner.nextSpawnTime += 16.6; }
            else if (getCurrentGameTime() >= spawner.nextSpawnTime) spawnRobber();
            if (gameState.slowAuraActiveTime > 0) gameState.slowAuraActiveTime--;
            if (++gameState.itemSpawnTimer > 3600 && Math.random() < 0.01) { gameState.itemSpawnTimer = 0; spawnRandomItem(); }
            items.forEach((it, i) => { if (it.worldX === worldState.x && it.worldY === worldState.y && Math.hypot(player.x-it.x, player.y-it.y) < 40) { if(it.type === 'FREEZE') gameState.freezeActiveTime = 600; else gameState.slowAuraActiveTime = 1800; items.splice(i, 1); showGameMessage(it.type + " 획득!", "cyan", 180); } });
            gameState.messages.forEach(m => m.life--); gameState.messages = gameState.messages.filter(m => m.life > 0);
            const speed = (keys.shift && player.stamina > 0 ? 4.5 : 2.5) - (gameState.prisoners * 0.15);
            if (keys.shift && player.stamina > 0 && (keys.w||keys.a||keys.s||keys.d)) player.stamina -= 0.5;
            let px = player.x, py = player.y;
            if (keys.w) py -= speed; if (keys.s) py += speed; if (keys.a) px -= speed; if (keys.d) px += speed;
            if (!checkCollision(player, px, py)) { player.x = px; player.y = py; }
            if (keys.w||keys.a||keys.s||keys.d) player.rotation = Math.atan2(py-player.y, px-player.x) || player.rotation;
            player.currentDisplaySpeed = (keys.w||keys.a||keys.s||keys.d) ? speed : 0;
            if (player.x < 0 && worldState.x > 0) { worldState.x--; createCity('left'); }
            else if (player.x > canvas.width && worldState.x < 2) { worldState.x++; createCity('right'); }
            else if (player.y < 0 && worldState.y > 0) { worldState.y--; createCity('up'); }
            else if (player.y > canvas.height && worldState.y < 2) { worldState.y++; createCity('down'); }
            if (policeStation && worldState.x === 1 && worldState.y === 1 && player.x > policeStation.x && player.x < policeStation.x+policeStation.w && player.y > policeStation.y && player.y < policeStation.y+policeStation.h) {
                if (!gameState.wasInStation) { gameState.wasInStation = true; player.stamina = 100; gameState.intelObtained = true; if (gameState.prisoners > 0) { gameState.score += gameState.prisoners * 100; gameState.arrests += gameState.prisoners; gameState.prisoners = 0; showGameMessage("✅ 이송 완료!", "lime", 120); } }
            } else gameState.wasInStation = false;
            robbers.forEach((r, i) => {
                if (r.worldX === worldState.x && r.worldY === worldState.y) {
                    if (gameState.freezeActiveTime <= 0) {
                        const dist = Math.hypot(player.x-r.x, player.y-r.y);
                        let s = dist < 200 ? r.sprintSpeed : r.baseSpeed;
                        if (gameState.slowAuraActiveTime > 0 && dist < 200) s *= 0.4;
                        if (!r.targetNode) { const n = getNearestNode(r.x, r.y); r.targetNode = dist < 200 ? getBestFleeNode(r, n) : n.neighbors[Math.floor(Math.random()*n.neighbors.length)]; }
                        else { const d = Math.hypot(r.targetNode.x-r.x, r.targetNode.y-r.y); r.x += (r.targetNode.x-r.x)/d*s; r.y += (r.targetNode.y-r.y)/d*s; if(d<5) r.targetNode = null; }
                    }
                    if (Math.hypot(player.x-r.x, player.y-r.y) < 30) { robbers.splice(i, 1); gameState.prisoners++; showGameMessage("체포 완료!", "#2ecc71", 120); }
                } else if (gameState.freezeActiveTime <= 0 && ++r.offScreenTimer > 300) { r.offScreenTimer = 0; r.worldX = Math.max(0, Math.min(2, r.worldX + Math.floor(Math.random()*3)-1)); r.worldY = Math.max(0, Math.min(2, r.worldY + Math.floor(Math.random()*3)-1)); }
            });
        }

        function draw() {
            if (gameState.screen === 'start') { drawStartScreen(); return; }
            if (gameState.screen === 'gameover') { ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
            ctx.fillStyle = "#111"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#444"; ctx.lineWidth = 40; ctx.lineCap = "round"; ctx.beginPath(); roadNodes.forEach(n => n.neighbors.forEach(o => { ctx.moveTo(n.x, n.y); ctx.lineTo(o.x, o.y); })); ctx.stroke();
            buildings.forEach(b => { ctx.fillStyle = b.color; ctx.fillRect(b.x, b.y, b.w, b.h); ctx.fillStyle = "rgba(255,255,255,0.1)"; for(let i=0; i<b.floors; i++) ctx.fillRect(b.x+10, b.y+10+i*20, 80, 10); });
            if (policeStation) { ctx.fillStyle = "#1a252f"; ctx.fillRect(policeStation.x, policeStation.y, policeStation.w, policeStation.h); ctx.strokeStyle = "#3498db"; ctx.lineWidth = 4; ctx.strokeRect(policeStation.x, policeStation.y, policeStation.w, policeStation.h); }
            robbers.forEach(r => { if(r.worldX === worldState.x && r.worldY === worldState.y) { ctx.fillStyle = r.color; ctx.beginPath(); ctx.arc(r.x, r.y, 10, 0, Math.PI*2); ctx.fill(); } });
            items.forEach(it => { if(it.worldX === worldState.x && it.worldY === worldState.y) { ctx.fillStyle = it.color; ctx.beginPath(); ctx.arc(it.x, it.y, 8, 0, Math.PI*2); ctx.fill(); } });
            ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.rotation); ctx.fillStyle = player.color; ctx.fillRect(-12, -8, 24, 16); ctx.fillStyle = "yellow"; ctx.fillRect(8, -7, 4, 4); ctx.fillRect(8, 3, 4, 4); ctx.restore();
            if (gameState.prisoners > 0) { ctx.fillStyle = "white"; ctx.font = "bold 12px Arial"; ctx.textAlign = "center"; ctx.fillText(`이송: ${gameState.prisoners}`, player.x, player.y-25); }
            maskCtx.clearRect(0,0,800,600); maskCtx.fillStyle = "rgba(0,0,0,0.6)"; maskCtx.fillRect(0,0,800,600); maskCtx.globalCompositeOperation = 'destination-out';
            maskCtx.beginPath(); maskCtx.arc(player.x, player.y, 250, 0, Math.PI*2); maskCtx.fill(); ctx.drawImage(maskCanvas, 0, 0);
            drawUI();
            if (gameState.isPaused) { ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0,0,800,600); ctx.fillStyle="white"; ctx.font="40px Malgun Gothic"; ctx.textAlign="center"; ctx.fillText("PAUSED", 400, 300); }
        }

        function drawUI() {
            gameState.messages.forEach((m, i) => { ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.font = "bold 15px Malgun Gothic"; const w = ctx.measureText(m.text).width; ctx.fillRect(400-w/2-5, 60+i*25, w+10, 20); ctx.fillStyle = m.color; ctx.textAlign="center"; ctx.fillText(m.text, 400, 75+i*25); });
            ctx.fillStyle = "white"; ctx.font = "bold 20px Malgun Gothic"; ctx.textAlign="center"; ctx.fillText(`SCORE: ${gameState.score}`, 400, 30);
            ctx.textAlign="left"; ctx.fillStyle = "#333"; ctx.fillRect(20, 50, 200, 15); ctx.fillStyle = player.stamina < 30 ? "red" : "cyan"; ctx.fillRect(20, 50, player.stamina*2, 15);
            const speedKmh = Math.round(player.currentDisplaySpeed * 32); ctx.fillStyle = "white"; ctx.font = "bold 24px Arial"; ctx.textAlign="center"; ctx.fillText(`${speedKmh} km/h`, 400, 570);
            const mmX = 690, mmY = 10; ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(mmX, mmY, 100, 100);
            ctx.fillStyle = "#2ecc71"; ctx.fillRect(mmX + worldState.x*33 + player.x/800*33 - 2, mmY + worldState.y*33 + player.y/600*33 - 2, 4, 4);
            if (gameState.intelObtained) robbers.forEach(r => { ctx.fillStyle = "red"; ctx.fillRect(mmX + r.worldX*33 + r.x/800*33 - 1, mmY + r.worldY*33 + r.y/600*33 - 1, 2, 2); });
            ctx.fillStyle = "white"; ctx.font = "12px Arial"; ctx.fillText(`도둑: ${robbers.length}/30`, mmX, mmY+115);
        }

        function drawStartScreen() { ctx.fillStyle = "#111"; ctx.fillRect(0,0,800,600); ctx.fillStyle="cyan"; ctx.font="bold 60px Malgun Gothic"; ctx.textAlign="center"; ctx.fillText("경찰 과 도둑", 400, 250); ctx.fillStyle="white"; ctx.font="20px Malgun Gothic"; ctx.fillText("마우스로 클릭하여 시작", 400, 350); }

        // 전역 키 이벤트 수정: Spacebar로 인한 게임 시작 방지
        window.addEventListener('keydown', e => { 
            if (e.code === 'KeyM') gameState.intelObtained = true; 
            if (e.code === 'Escape' && gameState.screen === 'playing') gameState.isPaused = !gameState.isPaused; 
            if (e.key === 'w' || e.key === 'W') keys.w = true; 
            if (e.key === 'a' || e.key === 'A') keys.a = true; 
            if (e.key === 's' || e.key === 'S') keys.s = true; 
            if (e.key === 'd' || e.key === 'D') keys.d = true; 
            if (e.key === 'Shift') keys.shift = true;
            // Spacebar 단축키 제거됨
        });
        window.addEventListener('keyup', e => { if (e.key === 'w' || e.key === 'W') keys.w = false; if (e.key === 'a' || e.key === 'A') keys.a = false; if (e.key === 's' || e.key === 'S') keys.s = false; if (e.key === 'd' || e.key === 'D') keys.d = false; if (e.key === 'Shift') keys.shift = false; });
        
        // 클릭 이벤트로만 게임 시작/재시작 관리
        canvas.addEventListener('mousedown', () => { 
            if (gameState.screen === 'start') initGame(); 
            // 게임오버 시에는 재시작 버튼 클릭으로만 작동하도록 제한함 (실수 방지)
        });

        function loop() { update(); draw(); requestAnimationFrame(loop); }
        loop();
    </script>
</body>
</html>